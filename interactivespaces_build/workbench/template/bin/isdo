#!/usr/bin/env python

# Copyright (C) 2015 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.


"""This is the command-line tool for interacting with Interactive Spaces."""

import os
import re
import sys
import json
import time
import glob
import errno
import thread
import threading
import subprocess
import xml.etree.ElementTree as ElementTree
import fnmatch
import itertools
import pprint
import logging
import requests

try:
  import websocket
except:
  print("WebSockets library not installed. Please install with `sudo pip install websocket-client`")
  print("If pip is not installed, please install with `sudo easy_install pip`")
  exit(1)

logging.basicConfig(level=logging.DEBUG)
logging.getLogger("urllib3").setLevel(logging.CRITICAL)
logging.getLogger("requests").setLevel(logging.CRITICAL)

ACTIVITY_UPDATE_DELAY = 3 # Seconds

INTERACTIVE_SPACES_NAMESPACES = {'is': 'http://interactive-spaces.org/project.xsd'}


def print_help():
  """Print help information and exits."""
  print("""Interactive Spaces command-line tool.

This tool handles common tasks for Interactive Spaces from the command line.

Some tasks require live activities, some require activities, and some \
require files. These can often be inferred from other information, but are never inferred \
when directly specified. Example: if --activity is supplied, the live activities can be \
inferred. However, if --live-activity is supplied, they will not be inferred.

Usage:
    isdo [-?]
    isdo [--flag [VALUE]? ...] [PATH...]?

General Flags:
    --help|-?                       Show help.
    --host|-h <HOST>                Specifies the host name (default: localhost)
    --port|-p <PORT>                Specifies the host port (default: 8090)
    --lenient                       Ignore non-fatal errors
    --silent                        Do not print to stdout
    --debug                         Show debugging information
    --verbose                       Show even more debugging information

Selection Flags:
    --live-activity | -L <REF>      Specifies an live activity to be used. The REF is
                                    required and can be the name, id, or UUID.
                                    An activity can be inferred from this.

    --activity | -A <NAME>          Specifies an activity to be used. The activity name is
                                    required.
                                    Live activities can be inferred from this.

    --version | -V <VERSION>        Specifies an activity version to be used. The version
                                    is required.
                                    This can be combined with --activity to only infer
                                    live activities which use a specific version of an activity.

    --group | -G <NAME>             Specifies a live activity group to be used. The group
                                    name is required.
                                    Live activities can be inferred from this.

    --controller | -C <UUID | NAME> Specifies a controller to be used. The controller
                                    UUID or name are required.
                                    Live activities can be inferred from this.

    --all                           Specifies all activities or live activities the master is
                                    aware of.
                                    Live activities and activities can be inferred from this.

    [PATH...]                       Provides a folder to search recursively for project
                                    files. If files are required and no paths are
                                    provided or no activities or live activities can be
                                    inferred, the current working directory will be used.
                                    Activities and live activities can be inferred from this.

Command Flags:
    --build | -b                    Recompiles projects (using isbuild). Requires files.

    --shutdown | -s                 Shuts down live activities. Requires live activities.

    --delete-live-activity          Deletes live activities. Requires live activities.

    --delete-activity               Deletes activities. Implies --shutdown and
                                    --delete-live-activity. Requires activities.

    --upload | -u                   Uploads projects to the master. Requires files.

    --create <NAME>                 Creates a new live activity. Name is required. The new
                                    live activity UUID is written to stdout. Requires a
                                    single activity and --controller flag.  --version
                                    is optional (defaults to highest version). After
                                    this command, if live activities have not been specified,
                                    only the newly created live activity will be inferred.

    --deploy | -d                   Pushes the latest activity and configuration to
                                    controllers. Implies --shutdown. Requires live activities.

    --config <FILE | ->             Changes the live activity configuration. Configuration is
                                    loaded from the file, or a dash indicates that data
                                    should be read from stdin. Requires live activities.

    --group-remove                  Removes live activities from a live activity group. Requires
                                    live activities and the --group flag.

    --group-delete                  Deletes a live activity group. Implies --group-remove.
                                    Requires live activities and the --group flag.

    --group-create                  Creates a new live activity group. Requires --group
                                    flag.

    --group-add                     Adds activities to a group. Requires activities and
                                    --group flag.

    --activate | -a                 Activates activities. Requires activities.

    --reactivate | -r               Records which live activities were not in the READY state
                                    when isdo started. Afterwards attempts to activate
                                    only those live activities. Requires live activities.

    --list | -l                     Lists structured data about activities, live activities and
                                    files.

    --run                           Shorthand to run activities. Implies --auto-configure,
                                    --deploy, and --activate. Requires files.

    --auto-configure                Creates and configures activities. For each project, this
                                    will look for ./config/*.conf files. If files are found,
                                    the base name of the files will be used as live activity
                                    names. If no files are found, the activity name will be
                                    used as a live activity name. Each activity will be
                                    uploaded and all live activities will be created (if
                                    necessary), configured using the contents of the *.conf
                                    files. Requires files.

Examples:

    Build and Run an Activity

        isdo --build --upload --deploy --reactivate

    Install an Exhibit

        GROUP=`isdo --group-delete --group-create Example --lenient` && \\
        isdo --upload /path/to/exhibit && \\
        isdo -C C1 -A com.example.a -c A  -d --config a.conf  -ga -G $GROUP && \\
        isdo -C C1 -A com.example.b -c B1 -d --config b1.conf -ga -G $GROUP && \\
        isdo -C C2 -A com.example.b -c B2 -d --config b2.conf -ga -G $GROUP && \\
        isdo -G $GROUP --activate && \\
        isdo -G $GROUP --list

    Wipe an Installation

        isdo --purge --all

""")
  exit(1)


def parse_command_line(arguments):
  """Parse command line arguments."""
  config = AttrDict()

  # Default Settings

  config.host_name = 'localhost'
  config.host_port = 8090
  config.host_path = 'masterapi/websocket'
  config.debug = False
  config.verbose = False
  config.silent = False
  config.strict = True
  config.live_activities = []
  config.activities = []
  config.groups = []
  config.folders = []
  config.controllers = []
  config.version = None
  config.all = False
  config.commands = {}
  config.live_activity_generated = False
  config.activity_generated = False

  while arguments:
    argument = arguments.pop(0)
    if argument in ['--help', '-?']:
      print_help()

    elif argument in ['--debug']:
      config.debug = True

    elif argument in ['--verbose']:
      arguments.append('--debug')
      config.verbose = True

    elif argument in ['--silent']:
      config.silent = True

    elif argument in ['--lenient']:
      config.strict = False

    elif argument in ['--host', '-h']:
      if not arguments:
        print_fatal('Host name not provided')
      config.host_name = arguments.pop(0)

    elif argument in ['--port', '-p']:
      if not arguments:
        print_fatal('Host port not provided')
      config.host_port = arguments.pop(0)

    elif argument in ['--live-activity', '-L']:
      if not arguments:
        print_fatal('Live activity Name, ID, or UUID not provided')
      config.live_activities.append(arguments.pop(0))

    elif argument in ['--activity', '-A']:
      if not arguments:
        print_fatal('Activity ID or Name not provided')
      config.activities.append(arguments.pop(0))

    elif argument in ['--version', '-V']:
      if not arguments:
        print_fatal('Activity version not provided')
      config.version = arguments.pop(0)

    elif argument in ['--group', '-G']:
      if not arguments:
        print_fatal('Group name not provided')
      config.groups.append(arguments.pop(0))

    elif argument in ['--controller', '-C']:
      if not arguments:
        print_fatal('Controller UUID not provided')
      config.controllers.append(arguments.pop(0))

    elif argument in ['--all']:
      config.all = True

    elif argument in ['--build', '-b']:
      config.commands[BuildCommand] = BuildCommand()

    elif argument in ['--shutdown', '-s']:
      config.commands[ShutdownCommand] = ShutdownCommand()

    elif argument in ['--delete-live-activity']:
      arguments.append('--shutdown')
      config.commands[DeleteLiveActivityCommand] = DeleteLiveActivityCommand()

    elif argument in ['--delete-activity']:
      arguments.append('--delete-live-activity')
      config.commands[DeleteActivityCommand] = DeleteActivityCommand()

    elif argument in ['--upload', '-u']:
      config.commands[UploadCommand] = UploadCommand()

    elif argument in ['--create']:
      if not arguments:
        print_fatal('Activity name not provided')
      config.commands[CreateCommand] = CreateCommand(arguments.pop(0))

    elif argument in ['--upgrade']:
      config.commands[UpgradeCommand] = UpgradeCommand()

    elif argument in ['--deploy', '-d']:
      arguments.append('--shutdown')
      config.commands[DeployCommand] = DeployCommand()

    elif argument in ['--config']:
      if not arguments:
        print_fatal('Config path not provided')
      config.commands[ConfigCommand] = ConfigCommand(arguments.pop(0))

    elif argument in ['--group-remove', '-gr']:
      config.commands[GroupRemoveCommand] = GroupRemoveCommand()

    elif argument in ['--group-delete', '-gd']:
      config.commands[GroupDeleteCommand] = GroupDeleteCommand()

    elif argument in ['--group-create', '-gc']:
      config.commands[GroupCreateCommand] = GroupCreateCommand()

    elif argument in ['--group-add', '-ga']:
      config.commands[GroupAddCommand] = GroupAddCommand()

    elif argument in ['--reactivate', '-r']:
      arguments.append('--shutdown')
      config.commands[ReactivateCommand] = ReactivateCommand()
      config.commands[ActivateCommand] = None

    elif argument in ['--activate', '-a']:
      config.commands[ActivateCommand] = ActivateCommand()
      config.commands[ReactivateCommand] = None

    elif argument in ['--list', '-l']:
      config.commands[ListCommand] = ListCommand()

    elif argument in ['--auto-configure', '--auto-config']:
      config.commands[CreateAndConfigCommand] = CreateAndConfigCommand()

    elif argument in ['--run', '-r']:
      arguments.append('--auto-configure')
      arguments.append('--deploy')
      arguments.append('--activate')

    else:
      config.folders.append(argument)

  config.known_controllers = {}
  config.known_activities = {}
  config.known_live_activities = {}
  config.selected_live_activities = {}
  config.selected_activities = {}
  config.selected_controllers = {}

  config.project_folders = {}
  config.states = None
  config.host_upload_url = "http://%s:%s/masterapi/activity/upload" % (config.host_name, config.host_port)

  return config


def execute_command_line(commands, debug=False, indent="", **kwargs):
  """Execute a command-line program."""
  output = subprocess.Popen(commands,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE,
                            **kwargs).stdout
  result = ""
  while True:
    line = output.readline()
    if line:
      result = result + line
      print_debug("%s%s" % (indent, line.rstrip()))
    else:
      break

  return result


class AttrDict(dict):
  """Dictionary that acts like a tuple."""
  def __init__(self, *args, **kwargs):
    super(AttrDict, self).__init__(*args, **kwargs)
    self.__dict__ = self


class Command(object):
  """Base class for command steps."""

  def set_config(self, config, server_connection):
    self.config = config
    self.validate(server_connection)

  def execute(self, server_connection):
    """Executes this task"""

    raise NotImplementedError("Command %s not implemented" % self.__class__.__name__)

  def prep(self):
    """Prepares this task for execution"""
    pass

  def validate(self, server_connection):
    """Validates this step's configuration. Override this to add custom validation steps."""
    pass

  def validate_has_files(self, fatal=True):
    if not self.config.folders:
      print_error('No files provided for command {}'.format(self.__class__.__name__), fatal=fatal)

  def validate_has_controller(self, fatal=True):
    if len(self.config.selected_controllers) != 1:
      print_error('Exactly one controller required for command {}, found {}'.format( \
          self.__class__.__name__, len(self.config.selected_controllers)), fatal=fatal)

  def validate_has_activity(self, fatal=True):
    if len(self.config.selected_activities) != 1:
      print_error('Exactly one activity required for command {}, found {}'.format( \
          self.__class__.__name__, len(self.config.selected_activities)), fatal=fatal)

  def validate_has_activities(self, fatal=True):
    if not self.config.selected_activities:
      print_error('No activities provided for command {}'.format(self.__class__.__name__), fatal=fatal)

  def validate_has_live_activity(self, fatal=True):
    if len(self.config.selected_live_activities) != 1 and not self.config.live_activity_generated:
      print_error('Exactly one live activity required for command {}, found {}'.format( \
          self.__class__.__name__, len(self.config.selected_live_activities)), fatal=fatal)

  def validate_has_live_activities(self, fatal=True):
    if not self.config.selected_activities and not self.config.live_activity_generated:
      print_error('No live activities provided for command {}'.format(self.__class__.__name__), fatal=fatal)

  def validate_has_group(self, fatal=True):
    print_fatal('Group commands not supported yet')

  def requires_server(self):
    """Indicates whether the command requires a connection to the server."""
    return True


class BuildCommand(Command):
  """Compiles one or more IS projects using isbuild."""

  def validate(self, *args, **kwargs):
    self.validate_has_files()

  def requires_server(self):
    return False

  def execute(self, server_connection):
    isbuild = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'isbuild')
    for folder in self.config.project_folders.iterkeys():
      print_debug("Building %s" % folder)
      execute_command_line([isbuild, folder], debug=self.config.debug, indent="  ")


class ShutdownCommand(Command):
  """Shuts down selected live activities."""

  def validate(self, *args, **kwargs):
    self.validate_has_live_activities(fatal=self.config.strict)

  def execute(self, server_connection):
    for live_activity in self.config.selected_live_activities:
      server_connection.send('/liveactivity/shutdown', { 'id': self.config.known_live_activities[live_activity]['id'] })


class DeleteLiveActivityCommand(Command):
  """Deletes live activities."""

  def validate(self, *args, **kwargs):
    self.validate_has_live_activities(fatal=self.config.strict)

  def execute(self, server_connection):
    for live_activity in self.config.selected_live_activities:
      server_connection.send('/liveactivity/delete/remote', { 'id': self.config.known_live_activities[live_activity]['id'] })
      server_connection.send('/liveactivity/delete/local', { 'id': self.config.known_live_activities[live_activity]['id'] })


class DeleteActivityCommand(Command):
  """Deletes activities."""

  def validate(self, *args, **kwargs):
    self.validate_has_activities(fatal=self.config.strict)


class UploadCommand(Command):
  """Uploads activities."""

  def validate(self, *args, **kwargs):
    self.validate_has_files()
    self.config.activity_generated = True

  def requires_server(self):
    return False

  def execute(self, server_connection):
    for (folder, activity) in self.config.project_folders.iteritems():
      activity_zip = os.path.join(folder, 'build', activity + '*.zip')
      for file in glob.glob(activity_zip):
        print_verbose('  Uploading %s' % file)
        with open(file, 'rb') as contents:
          result = requests.post(self.config.host_upload_url, files={'file': contents})
        if result.status_code >= 400:
          print_fatal("Activity Upload Failed: %s\n%s" % (result.status_code, result.text))
        else:
          result_data = json.loads(result.text)
          if result_data["result"] == "success":
            activity_data = result_data["data"]
            self.config.known_activities[activity_data["id"]] = activity_data
            self.config.selected_activities[activity_data["id"]] = activity_data
            print_debug('  Uploaded  %s - %s' % (file, activity_data["identifyingName"]))
          else:
            print_fatal("Activity Upload Failed: %s" % result_data["reason"])




class CreateAndConfigCommand(Command):
  """Creates and configures new live activities if necessary."""

  def validate(self, *args, **kwargs):
    self.validate_has_files()

    super(CreateAndConfigCommand, self).validate(*args)
    self.config.live_activity_generated = True

    self.configs = {}
    for folder, activity_name in self.config.project_folders.iteritems():
      has_config = False
      config_folder = os.path.join(folder, "config")
      if os.path.exists(config_folder):
        for config_file in fnmatch.filter(os.listdir(config_folder), '*.conf'):
          has_config = True
          name = os.path.splitext(os.path.basename(config_file))[0]
          with open (os.path.join(config_folder, config_file), "r") as config_file_stream:
            self.configs[name] = {
              'name': name,
              'activity': activity_name,
              'contents': ConfigCommand.parse_config(config_file_stream.read()) }

      if not has_config:
        self.configs[activity_name] = {
          'name': activity_name,
          'activity': activity_name,
          'contents': {} }

  def execute(self, server_connection):
    for config in self.configs.itervalues():
      # Get the live activity id.
      live_activity_id = next(iter(a['id'] for a in self.config.known_live_activities.itervalues() if a['name'] == config['name']), None)
      if not live_activity_id:
        # We need to create the live activity, set get the activity id and controller and use those to create it.
        activity_id = next(iter(a['id'] for a in self.config.known_activities.itervalues() if a['identifyingName'] == config['activity']))
        controller_id = next(iter(self.config.known_controllers.itervalues()))['id']
        live_activity_id = CreateCommand.create(server_connection, self.config, config['name'], activity_id, controller_id)['id']

      # Configure the live activity.
      ConfigCommand.config(server_connection, live_activity_id, config['contents'])


class CreateCommand(Command):
  """Creates a new live activity for a given activity."""

  def __init__(self, name):
    self.name = name

  def validate(self, *args, **kwargs):
    self.validate_has_controller()
    self.validate_has_activity()

    self.config.live_activity_generated = True

  def execute(self, server_connection):
    activityId = iter(self.config.selected_activities).next()
    controllerId = self.config.known_controllers[iter(self.config.selected_controllers).next()]['id']

    CreateCommand.create(server_connection,
                         self.config,
                         self.name,
                         iter(self.config.selected_activities).next(),
                         self.config.known_controllers[iter(self.config.selected_controllers).next()]['id'])

  @staticmethod
  def create(server_connection, config, name, activity_id, controller_id):
    result = server_connection.send('/liveactivity/create', { 'name': name,
                                                              'activityId': str(activity_id),
                                                              'spaceControllerId': str(controller_id) })

    try:
      config.known_live_activities[result['data']['uuid']] = result['data']
      config.selected_live_activities[result['data']['uuid']] = result['data']
    except Exception as e:
      print_fatal("Server returned unexpected data:\n{}".format(result))

    return result['data']


class UpgradeCommand(Command):
  """Changes the version of a live activity."""

  def validate(self, *args, **kwargs):
    print_fatal('--upgrade option not supported yet')


class DeployCommand(Command):
  """Deploys the last uploaded bundle of a live activity."""

  def validate(self, *args, **kwargs):
    self.validate_has_live_activities(fatal=self.config.strict)

  def execute(self, server_connection):
    for live_activity in self.config.selected_live_activities:
      server_connection.send('/liveactivity/deploy', { 'id': self.config.known_live_activities[live_activity]['id'] })
      server_connection.send('/liveactivity/configure', { 'id': self.config.known_live_activities[live_activity]['id'] })



class ConfigCommand(Command):
  """Writes an updated configuration for an activity."""

  def __init__(self, path):
    self.path = path

  def validate(self, *args, **kwargs):
    self.validate_has_live_activity()

    if self.path != '-':
      if os.path.exists(self.path):
        try:
          with open (self.path, "r") as config_file:
            self.contents = config_file.read()
        except Exception as e:
          print_fatal('Reading from configuration file "%s" failed - %s' % (self.path, e))
      else:
        print_fatal('Configuration file "%s" not found' % self.path)

  def prep(self):
    if self.path == '-':
      self.contents = sys.stdin.read()

    self.map = ConfigCommand.parse_config(self.contents)

  def execute(self, server_connection):
    for live_activity in self.config.selected_live_activities:
      ConfigCommand.config(server_connection, self.config.known_live_activities[live_activity]['id'], self.map)

  @staticmethod
  def parse_config(contents):
    # TODO: Support comments (lines start with # or !)

    result = {}
    for match in re.findall("^\s*(.+?)\s*=\s*(.*?)\s*$", contents, flags=re.MULTILINE):
      result[match[0]] = match[1]
    return result

  @staticmethod
  def config(server_connection, live_activity_id, map):
    server_connection.send('/liveactivity/configuration/set', { 'id': str(live_activity_id), 'config': map })
    server_connection.send('/liveactivity/configure', { 'id': str(live_activity_id) })


class GroupRemoveCommand(Command):
  """Removes live activities from a live activity group."""

  def validate(self, *args, **kwargs):
    self.validate_has_live_activities(fatal=self.config.strict)
    self.validate_has_group(fatal=self.config.strict)


class GroupDeleteCommand(Command):
  """Deletes a live activtiy group."""

  def validate(self, *args, **kwargs):
    self.validate_has_group(fatal=self.config.strict)


class GroupCreateCommand(Command):
  """Creates a live activity group."""

  def validate(self, *args, **kwargs):
    self.validate_has_group(fatal=self.config.strict)


class GroupAddCommand(Command):
  """Adds live activities to a live activity group."""

  def validate(self, *args, **kwargs):
    self.validate_has_live_activities()
    self.validate_has_group(fatal=self.config.strict)


class ActivateCommand(Command):
  """Activates live activities."""
  def validate(self, *args, **kwargs):
    self.validate_has_live_activities(fatal=self.config.strict)

  def execute(self, server_connection):
    for live_activity in self.config.selected_live_activities.itervalues():
      print_debug('Activating {}'.format(live_activity['id']))
      server_connection.send('/liveactivity/activate', { 'id': live_activity['id'] })


class ReactivateCommand(Command):
  """Reactivates live activities."""
  ACTIVE_STATES = [ 'ACTIVE',
                    'STARTUP_FAILURE',
                    'RUNNING' ]

  def prep(self, server_connection):
    print_verbose("Getting server state")
    server_connection.send("/spacecontroller/all/status", expect_response=False)
    print_verbose("Waiting for activity state to settle")
    time.sleep(ACTIVITY_UPDATE_DELAY)
    self.list = [a['id'] for a in server_connection.send("/liveactivity/all")['data'] \
                 if a['active']['runtimeState'] in ActivateCommand.ACTIVE_STATES]
    print_debug('{} live activities scheduled for re-activation'.format(len(self.list)))

  def execute(self, server_connection):
    if self.config.states:
      for live_activity_id in self.list:
        print_verbose('Reactivating {}'.format(live_activity_id))
        server_connection.send('/liveactivity/activate', { 'id': live_activity_id })


class ListCommand(Command):
  """Writes out deployment and state information about activities and live activities."""

  def execute(self, server_connection):
    remaining_activities = set([a['id'] for a in self.config.selected_activities.itervalues()])
    remaining_live_activities = set([a['uuid'] for a in self.config.selected_live_activities.itervalues()])

    for folder, activity_name in sorted(self.config.project_folders.iteritems()):
      activity = next((a for a in self.config.known_activities.itervalues() if a['identifyingName'] == activity_name),
                      {'id': '???', 'name': activity_name})
      self.write_folder(folder, [activity], remaining_activities, remaining_live_activities)

    if remaining_activities:
      self.write_folder('[Unknown Project Folder]',
                        [a for a in self.config.known_activities.itervalues() if a['id'] in remaining_activities],
                        remaining_activities, remaining_live_activities)

    if remaining_live_activities:
      print_output("[Unknown Activity]")
      for live_activity in self.config.live_activities.itervalues():
        if live_activity['uuid'] in remaining_live_activities:
          self.write_live_activity(live_activity, remaining_live_activities, indent=2)

    print_output("-" * 50)
    print_output("%d Paths, %d Activities, %d Live Activities" % (len(self.config.project_folders),
                                                                len(self.config.selected_activities),
                                                                len(self.config.selected_live_activities)))


  def write_folder(self, folder, activities, remaining_activities, remaining_live_activities):
    print_output(folder)
    for activity in sorted(activities):
      self.write_activity(activity, remaining_activities, remaining_live_activities)

  def write_activity(self, activity, remaining_activities, remaining_live_activities):
    remaining_activities.discard(activity['id'])
    print_output('  [%s] %s' % (activity['id'], activity['name']))
    for live_activity in self.config.known_live_activities.itervalues():
      if live_activity['activity']['id'] == activity['id']:
        self.write_live_activity(live_activity, remaining_live_activities)

  def write_live_activity(self, live_activity, remaining_live_activities, indent=4):
    remaining_live_activities.discard(live_activity['uuid'])
    print_output("%s[%s] %s" % ((' ' * indent), live_activity['uuid'], live_activity['name']))


class MasterConnection(object):
  """Handles websocket connection to master."""

  def __init__(self, config):
    url = "ws://%s:%s/%s" % (config.host_name, config.host_port, config.host_path)
    print_verbose('Connecting to server at %s' % url)

    self._config = config
    self._lock = threading.Condition()
    self._closing = False
    self._responses = {}
    self._next_id = 0
    self._ws = websocket.WebSocketApp(url,
                                      on_open=self._on_open,
                                      on_message=self._on_message,
                                      on_error=self._on_error,
                                      on_close=self._on_close)

    self._lock.acquire()
    thread.start_new_thread(self._run_forever, ())
    self._lock.wait()
    self._lock.release()

    print_debug('Connected to server at %s' % url)

  def _run_forever(self):
    try:
      self._ws.run_forever()
    except Exception as e:
      print_fatal("!!!" + str(e))
      raise e

  def _on_open(self, socket):
    self._lock.acquire()
    self._lock.notify_all()
    self._lock.release()

  def _on_message(self, socket, message):
    parsed_message = json.loads(message)
    id = parsed_message.get("requestId")

    if id:
      print_verbose('<-- [%s] %s' % (id, parsed_message.get("result")))
      self._lock.acquire()
      self._responses[id] = AttrDict(parsed_message)
      self._lock.notify_all()
      self._lock.release()
    else:
      print_verbose('<-- {%s}' % parsed_message.get("type"))

  def _on_error(self, socket, error):
    print_fatal('Connection to server error: %s' % error)

  def _on_close(self, socket):
    if not self._closing:
      print_fatal('Connection to server closed unexpectedly')
    else:
      print_verbose('Connection to server closed')

    self._lock.acquire()
    self._lock.notify_all()
    self._lock.release()


  def send(self, message_type, arguments={}, wait_for_response=None, expect_response=True):
    """Sends a message to the master and either waits for a response and returns it, returns a token that can be used
    to wait for a response, or returns a blank string if no response is expected."""

    if wait_for_response is None:
      wait_for_response = expect_response

    self._lock.acquire()
    try:
      if expect_response or wait_for_response:
        self._next_id += 1
        id = str(self._next_id)
      else:
        id = ""

      message = { 'requestId': id,
                  'type': message_type,
                  'data': arguments }

      print_verbose('--> [%s] %s %s' % (id, message_type, arguments or ""))

      self._ws.send(json.dumps(message))
    finally:
      self._lock.release()

    if wait_for_response:
      return self.wait_for_response(id)
    else:
      return id

  def wait_for_response(self, id):
    """Waits for a specific response by id and returns it."""

    self._lock.acquire()
    try:
      while True:
        if not self._ws.sock:
          return None
        elif id in self._responses:
          result = self._responses[id]
          del self._responses[id]
          return result
        self._lock.wait()
    finally:
      self._lock.release()

  def shutdown(self):
    """Shuts down the websocket connection, signalling to all listeners that no more responses are coming."""
    print_verbose('Closing connection to server')

    self._lock.acquire()
    try:
      self._closing = True
      self._ws.close()
      self._lock.wait()
    finally:
      self._lock.release()



class Runner(object):
  """Main script runner."""

  command_order = [ BuildCommand,
                    ShutdownCommand,
                    DeleteLiveActivityCommand,
                    DeleteActivityCommand,
                    UploadCommand,
                    CreateAndConfigCommand,
                    CreateCommand,
                    UpgradeCommand,
                    DeployCommand,
                    ConfigCommand,
                    GroupRemoveCommand,
                    GroupDeleteCommand,
                    GroupCreateCommand,
                    GroupAddCommand,
                    ActivateCommand,
                    ReactivateCommand,
                    ListCommand ]


  def run(self, config):
    self._find_projects(config)

    server_connection = self._configure_commands(config)

    self._execute_commands(config, server_connection)

    if server_connection:
      server_connection.shutdown()


  def _configure_commands(self, config):
    server_connection = None
    count = 0
    for command_name in Runner.command_order:
      command = config.commands.get(command_name)
      if command:
        if command.requires_server() and not server_connection:
          server_connection = MasterConnection(config)
          self._load_server_data(config, server_connection)
          self._find_selections(config)

        count += 1
        config.commands[command_name].set_config(config, server_connection)

    if not count:
      print_help()

    return server_connection


  def _execute_commands(self, config, server_connection):
    for command_name in Runner.command_order:
      command = config.commands.get(command_name)
      if command:
        command.prep()

    for command_name in Runner.command_order:
      command = config.commands.get(command_name)
      if command:
        print_verbose('Executing Command: %s' % command.__class__.__name__)
        command.execute(server_connection)


  def _load_server_data(self, config, server_connection):
    config.known_controllers     = {a['uuid']: a for a in server_connection.send('/spacecontroller/all')['data']}
    config.known_activities      = {a['id']:   a for a in server_connection.send('/activity/all')['data']}
    config.known_live_activities = {a['uuid']: a for a in server_connection.send('/liveactivity/all')['data']}

    print_debug_list('Known Controllers', config.known_controllers, '{} - {}', 'uuid', 'name')
    print_debug_list('Known Activities', config.known_activities, '{} - {}', 'id', 'identifyingName')
    print_debug_list('Known Live Activities', config.known_live_activities, '{} - {}', 'uuid', 'name')


  def _find_selections(self, config):
    config.selected_live_activities = {}
    config.selected_activities = {}
    config.selected_controllers = {}

    # Explicit Controllers
    config.selected_controllers.update({a['uuid']: a for a in config.known_controllers.itervalues() if \
        a['uuid'] in config.controllers or \
        a['id'] in config.controllers or \
        a['name'] in config.controllers or \
        a['hostId'] in config.controllers or \
        config.all})
    print_debug_list('Explicitly Selected Controllers', config.selected_controllers, '{} - {}', 'uuid', 'name')

    # Explicit Activities
    config.selected_activities.update({a['id']: a for a in config.known_activities.itervalues() if \
        a['id'] in config.activities or \
        a['identifyingName'] in config.activities or \
        config.all})
    print_debug_list('Explicitly Selected Activities', config.selected_activities, '{} - {}', 'id', 'identifyingName')

    # Explicit Live Activities
    config.selected_live_activities.update({a['uuid']: a for a in config.known_live_activities.itervalues() if \
        a['uuid'] in config.live_activities or \
        a['id'] in config.live_activities or \
        a['name'] in config.live_activities or \
        config.all})
    print_debug_list('Explicitly Selected Live Activities', config.selected_live_activities, '{} - {}', 'uuid', 'name')

    # Implicit Activities <-- Project Folders
    if not config.selected_activities:
      config.selected_activities.update({a['id']: a for a in config.known_activities.itervalues() if \
          a['identifyingName'] in config.project_folders.itervalues()})

      print_debug_list('Implicitly Selected Activities (from project files)', config.selected_activities, '{} - {}', 'id', 'identifyingName')

    # Implicit Live Activities
    if not config.selected_live_activities:
      for activity in config.selected_activities.itervalues():
        config.selected_live_activities.update({live_activity['uuid']: live_activity \
            for live_activity in config.known_live_activities.itervalues() if live_activity['activity']['id'] == activity['id']})
      for controller in config.selected_controllers.itervalues():
        config.selected_live_activities.update({live_activity['uuid']: live_activity \
            for live_activity in config.known_live_activities.itervalues() if live_activity['controller']['uuid'] == controller['uuid']})

      print_debug_list('Implicitly Selected Live Activities (from live activities and controllers)', config.selected_live_activities, '{} - {}', 'uuid', 'name')

    # Implicit Activities <-- Live Activities
    if not config.selected_activities:
      for live_activity in config.selected_live_activities:
        activity = config.known_activities[config.known_live_activities[live_activity]['activity']['id']]
        config.selected_activities[activity['id']] = activity

      print_debug_list('Implicitly Selected Activities (from live activities)', config.selected_activities, '{} - {}', 'id', 'identifyingName')

    # Implicit Controllers <-- Activities
    if not config.selected_controllers:
      for live_activity in config.selected_live_activities:
        controller = config.known_controllers[config.known_live_activities[live_activity]['controller']['uuid']]
        config.selected_controllers[controller['uuid']] = controller

      print_debug_list('Implicitly Selected Controllers (from activities)', config.selected_controllers, '{} - {}', 'uuid', 'name')


  def _find_projects(self, config):
    config.project_folders = {}

    for folder in config.folders:
      if not os.path.isdir(folder):
        error = 'Path \'{}\' not found'.format(folder)
        if folder[0] == '-':
          print_fatal(error + '\nIt looks like you were trying to use an unrecognized option. Use \'-?\' for a list of all options')
        else:
          print_fatal(error)

      for root, dirs, files in os.walk(folder, followlinks=True):
        if '.git' in dirs:
          # os.walk uses the dirs collection to determine subsequent folder recursion.
          dirs.remove('.git')

        if fnmatch.filter(files, 'project.xml'):
          path = os.path.join(root, 'project.xml')
          print_verbose('Loading ' + path)

          tree = ElementTree.parse(path)
          if tree.getroot().get('type') != 'assembly':
            activity_node = tree.find('./identifyingName')
            if activity_node is not None:
              activity_name = activity_node.text.strip()
            else:
              activity_name = tree.find('./is:identifyingName', INTERACTIVE_SPACES_NAMESPACES).text.strip()
            config.project_folders[os.path.abspath(root)] = activity_name

config = None

def print_debug_list(title, list, format, *args):
  """Prints a list of items using the keys specified in *args"""
  if list:
    print_debug(title)
    for item in list.itervalues():
      print_debug('  ' + format.format(*[item.get(arg) for arg in args]))
    print_debug('')

def print_verbose(text):
  """Prints only if the --verbose flag was used."""
  if config.verbose:
    print_output(text)

def print_debug(text):
  """Prints only if the --debug flag was used."""
  if config.debug or config.verbose:
    print_output(text)

def print_error(text, fatal=False):
  """Prints an error. If fatal, the program will end."""
  for line in text.split('\n'):
    print(("Fatal: " if fatal else "Error: ") + line)
  if fatal or config.strict:
    exit(1)

def print_fatal(text):
  """Prints a fatal error and exits the program."""
  print_error(text, fatal=True)

def print_output(text):
  """Prints text unless the --silent flag was used."""
  if not config.silent:
    print(text)


if __name__ == '__main__':
  config = parse_command_line(sys.argv[1:])
  Runner().run(config)

